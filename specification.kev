
/*
        Welcome to the Kevlar language specification!
        Kevlar is a high-level programming language that
        aims to combine great flexibility while providing
        high performance and memory safety.
        
        Kevlar uses a runtime content-id memory management system to ensure memory 
        safety while keeping flexibility and performance.

        Anything stored in memory has an identifier used to validate access. 
        The owner of a memory block holds a special pointer for direct access, while copies 
        hold a copy pointer containing a memory address and an identifier. When a copy attempts to 
        access memory, it must first verify its stored identifier against the content identifier.
        This check ensures that copies cannot access deallocated or invalid memory.

        Ownership can be transferred but never shared, and deallocation sets the content identifier to 
        an impossible value, preventing further access from any remaining copies. An increment-based 
        ID generator, optimized by the compiler, manages identifiers to minimize overhead while maintaining 
        memory safety.

        However, unlike Rust's ownership system, Kevlar allows for multiple copy pointers to exist
        concurrently, with both read and write access. This allows for much more flexibility.

        This document demonstrates all syntax in Kevlar.
*/

// This is a single line comment

/*
    This is a 
    multi-line comment
*/

/*
 *      This is an inline documentation
 *
 *      @param name<type> example parameter
 *      @return<type> example return
 *
*/

/*      IMPORTS       */
// Module system may be revamped in the future

// import a kevlar file in project
use "@/path/to/file";            // absolute path
use "./path/to/file";            // relative path

// import a Kevlar file in the environment
use "kevlar/std";

// import as another name
use "path/to/kevlar" as Foo;

// import and destructure
use "path/to/kevlar" as { item1, item2, item3 };      // only keep specific items
use "path/to/kevlar" as { * };                        // destructure all

// kevlar/core is automatically imported and destructured
//use "kevlar/core" as { * }


/*      VARIABLES       */
/*
    A variable is defined using one of the following format
    type name = value;
    type name;

    for the second way, a default value will be used instead. 
    The following example variable definition uses the default value
*/

// primary types

/*
    you can specify an allocated size for numeric primary types like this
    
    type<bit> name = value;
    
    If no size is specified, default values will be used instead which are shown below

    "auto" can be used to match the operating system's architecture

    Implicit type conversion happens when the conversion is lossless (e.g. int to float)
    Lossy conversions needs to be forced (e,g, float to int)
*/

int<auto> integer = 0;
uint<auto> unsignedInt = 0;
dec<64> decimal = 0.0;
bool boolean = false;
char character = 0!;        // explination mark forces type conversion, by default char stores the null character (unicode 0)
//char character = 0(char)  // you can also specify the type to convert to

/*
    "type" is a primary type used internally to identify different variable types.
    The code shown below is invalid as you cannot define a variable in "type",
    it is intended to be used for runtime type checking.
*/
//type typeId;

// define a constant
const int constant = 0;          

// referenced types
/*
    There are two kinds of constructors: Function and Literal
    A function constructor is a function that returns the constructed object
    Literal constructor allows you to use custom literals to define
    more complex objects while keeping good readability.

    This allow other smaller-scale languages to be embedded in Kevlar code.
    (e.g. HTML, SQL Queries, RegEx)

    See CLASS section for details

    If a referenced type is not assigned a value, it will default to null.

    All primary types have their referenced type counterpart.
    Memory size is now passed as a parameter

    Referenced variables are by default de-referenced when used, except for a few cases:
    1. When assigning as value to another variable, this creates a copy pointer
    2. When assigned a new value, this will pass the pointer
    3. When passes as parameter, this creates a copy pointer
    4. When used on comparison operators, this will instead compare pointers instead.
       Comparing an owner pointer to copy pointer of the same piece content returns true;
*/

Object func = new Object();   // function constructor
Object liter = Object {         // literals consturctor
    item1: item1,
    item2: item2,
}


Function funcVar = () => {};    // create and store a lambda function, see section "FLOW CONTROL"

// both double and single quotes can be used to define a string. They have different escapes.
String doubleQuoteStr = "abc";
String singleQuoteStr = 'abc';

// union typing
( Type1 | Type2 | Type3 ) unionTypeVar;

/*      OPERATORS       */ 
/*
        Assignment operators
    Include all assignment operators in C++
    <-          Transfer memory ownership
    <~          Dereference and assign value
    drop        Delete variable
    ...         Spread operation
    \=          Swap values

        Arithmetic Operators
    Include all Arithmetic operators in C++

        Comparason Operators
    Include all Comparason Operators in C++

        Logical Operators
    Include all Logical Operators in C++

        Bitwise Operators 
    Include all bitwise operators in c++

        Increment/Decrement Operators
    Same as C++

        Contional Operator
    Same as C++

        Type Operators
    !           Force type conversion based on context
    (<type>)    Force type conversion to specified type

*/


/*      FLOW CONTROL    */
// Kevlar uses the same set of logic statements as C, here we will skip them to save space

/*
    Anonymous function is defined using this syntax:
    [@captureByReference, %captureByValue](type param1, type param2)<returnType> => {
        // do something
        retvar = someValue;
        return;
    }

    Capture all by reference:
    [@](type param1, type param2)<returnType> => {
        // do something
        retvar = someValue;
        return;
    }

    Capture all by value:
    [%](type param1, type param2)<returnType> => {
        // do something
        retvar = someValue;
        return;
    }

    If implicitly captured, primary variables will be captured by value and objects will be captured by reference.

    Full implicit capturing
    (type param1)<returnType> => {
        // do something
        retvar = someValue;
        return;
    }

    Return type can be implicit

    Implicit return typing
    (type param1) => {
        // do something
        retvar = 1;
        return;
    }

    Implicit returning
    (type param1) => Math.sqrt(param1);

    If all above implicits are used, paranthesis around args can be removed
    type param1 => Math.pow(param1, 3);

    Notice how the return value is assigned to the variable "retvar" instead of as an arg for the return keyword?
    In Kevlar, functions always returns by output parameter to ensure maximum memory efficiency.
    If the returned value is not used by the caller, retval will act as a regular local variable.

    null can be used as a return type to indicate no return
    Auto-captured variables follow this rule: all primaries are pass by value, and any references 
    are pass by reference.
*/

(int param1, String param2)<int<32>> => {
    // do something
    retvar = 1;
    return;
}

/*
    Regular function is defined like this:
    returnType name(type param1, type param2){
        // do something
        retvar = returnValue;
    }
    A regular function only have access to global variables
*/
null foo(int param1, Object param2){
    // do something
}

// used for future testing
null println(Object value){
    // implement print logic
}

/*      MEMORY MANAGEMENT     */
/*
    Kevlin uses a unique runtime content-identifier-ownership system as mentioned in the start
    Every memory content have an id and an owner unless specificly opted out.
    When you assign a variable to a referenced variable, a copy pointer is assigned.
    When a copy pointer is accessed, it will first check it's own content id against the one stored in memory.
*/
Object funcCopy = func;

/*
    Owner variable is responsible for the lifetime of the content.
    If owner no longer used, assigned a new value, or manually 
    deallocated, its memory is freed. After that, an attempt to use 
    any copy will result in crashing.
*/
drop func;      // this deletes the owner variable and therefore the memory content
//foo(0, funcCopy);         // this will crash the program since funcCopy's owner is deallocated

/*
    You can skip copy pointer id checking for better performance
    THIS IS MEMORY UNSAFE, USE WITH CAUTION
*/
//foo(0, (DIRECT funcCopy));          // causes undefined behaviour

// ownership can also be transfered
String newStr <- doubleQuoteStr;                        // transfer ownership, original variable now holds a copy pointer
String newSingleStr <- singleQuoteStr = "other value";  // transfer ownership and assign a new value to original variable
newStr <- drop singleQuoteStr;                          // transfer ownership and deletes variable

/*
    content identifiers will eventually run out, requiring a global reset.
    During the reset, performance may be impacted. Because of this, we allow
    developers to indicate when will be the best time to do the global reset.

    If there are no indication, global reset will be delayed as much as possible,
    but it will happen inevitably. 
    
    Reusing already allocated memory space is encouraged, as creating new
    pointers consumes available IDs. When id pool reduces to a certain amount,
    a global reset will be performed to continue to ensure memory safety.

    When a global reset is performed, the program will run through the entire memory,
    collect any pointers, and assign them along with their respective content a new id.
    When assigning content new IDs, they will be scanned for any existing pointer too,
    and the process repeats.

    During a global reset, access of copy pointer exclude the ones using DIRECT
    will be routed through a table of already reset pointers. If the pointer is not
    found in the table, that pointer will be reset before accessing content.
*/

// reuse memory space
newStr <~ "Hello World!";

// this marks this specific place in program to be ideal for a global reset to start.
Process.allowReset();


/*      CLASSES      */

// Note that any OOB related features are not fixed and may be changed in the future

// define a class that inheritant another class
class ExampleClass extends AbstractClass implements MyInteface{
    
    /*
        Variables and functions (other than the constructors) in 
        classes are private by default.
        they can be made public by adding the keyword "expose"
        before definition
    */

    // private variable
    int privVar

    // public variable
    expose const int pubVar

    // static public variable
    expose static int statPubVar;

    // private function
    int privFunc(dec param1) {
        return 1;
    }

    // public function

    expose int pubFunc() {
        return 1;
    }

    // function constructor
    #constructor(){

        // you can call the parent contructor
        super();
        
    }

    // literal constructor
    #literal(){
        /*
            Literal constructors are not executed on runtime.
            Instead, they are executed by the compiler through
            all literal constructor calls when compiling.
            Their job is to evaluate the object literals as strings,
            and call the actual constructor to construct the class instance.
        */
    }
    
    // customly implemented operators
    int #operator+(ExampleClass var1, ExampleClass var2){ return 0; }
    // this is supported for all operators available
    
    // implement declarative foreach loop
    #iterator(Function iterate){
        iterate([0]);
    }
}

// define an abstract class
abstract class AbstractClass {
    
    // unimplemented function (must be implemented when inheritanted)
    int privFunc(dec param1);
    
    constructor(){
        
    }

    literal(){ }
}

// define an interface
interface MyInterface{
    
    int privVar;

    expose int pubVar;

    expose int pubFunc();

    // constructors are not allowed in an interface

}

// To be continued...
